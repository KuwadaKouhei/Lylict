'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useDispatch } from 'react-redux';
import { getAllMindMaps, deleteMindMap, MindMap } from '@/lib/mindmapService';
import { AppDispatch } from '@/lib/store';
import { createAutoGeneratedMindMap } from '@/lib/features/mindmap/mindmapSlice';
import { onAuthStateChange } from '@/lib/auth';
import { User } from 'firebase/auth';
import TitleInputModal from '@/components/TitleInputModal';
import LoginButton from '@/components/LoginButton';
import styles from './page.module.css';

export default function Home() {
  const [mindMaps, setMindMaps] = useState<MindMap[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showTitleModal, setShowTitleModal] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationProgress, setGenerationProgress] = useState('');
  const [user, setUser] = useState<User | null>(null);
  const router = useRouter();
  const dispatch: AppDispatch = useDispatch();

  useEffect(() => {
    // Ë™çË®ºÁä∂ÊÖã„ÅÆÁõ£Ë¶ñ
    const unsubscribe = onAuthStateChange((user) => {
      setUser(user);
      // „É¶„Éº„Ç∂„Éº„Åå„É≠„Ç∞„Ç§„É≥„Åó„Åü„Çâ„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÇíË™≠„ÅøËæº„Åø
      if (user) {
        loadMindMaps();
      } else {
        setMindMaps([]);
        setLoading(false); // Êú™Ë™çË®º„ÅÆÂ†¥Âêà„ÅØ„É≠„Éº„Éá„Ç£„É≥„Ç∞„ÇíÁµÇ‰∫Ü
      }
    });
    
    // „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆ„Ç¢„É≥„Éû„Ç¶„É≥„ÉàÊôÇ„Å´„É≠„Éº„Éá„Ç£„É≥„Ç∞Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
    return () => {
      setIsGenerating(false);
      setGenerationProgress('');
      unsubscribe();
    };
  }, []);

  const loadMindMaps = async () => {
    try {
      setLoading(true);
      setError(null);
      const maps = await getAllMindMaps();
      setMindMaps(maps);
    } catch (err: any) {
      console.error('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÅÆË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', err);
      if (err.message === 'AUTHENTICATION_REQUIRED') {
        // Ë™çË®º„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÁ©∫„ÅÆÈÖçÂàó„Çí„Çª„ÉÉ„Éà„Åó„Å¶„Ç®„É©„Éº„ÅØË°®Á§∫„Åó„Å™„ÅÑ
        setMindMaps([]);
        setError(null); // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇÇ„ÇØ„É™„Ç¢
      } else {
        setError('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÅÆË™≠„ÅøËæº„Åø‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
      }
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm('„Åì„ÅÆ„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
    
    try {
      await deleteMindMap(id);
      setMindMaps(mindMaps.filter(map => map.id !== id));
    } catch (err) {
      console.error('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÅÆÂâäÈô§„Ç®„É©„Éº:', err);
      setError('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÅÆÂâäÈô§‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
    }
  };

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const handleCreateNew = () => {
    if (!user) {
      alert('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê„Åô„Çã„Å´„ÅØ„ÄÅ„Åæ„Åö„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
      return;
    }
    setShowTitleModal(true);
  };

  const handleTitleConfirm = (title: string, firstWord: string) => {
    setShowTitleModal(false);
    // „Çø„Ç§„Éà„É´„Å®ÊúÄÂàù„ÅÆ„ÉØ„Éº„Éâ„ÇíURL„Éë„É©„É°„Éº„Çø„Å®„Åó„Å¶Ê∏°„Åó„Å¶„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„ÉóÁîªÈù¢„Å´ÈÅ∑Áßª
    router.push(`/mindmap?title=${encodeURIComponent(title)}&firstWord=${encodeURIComponent(firstWord)}`);
  };

  const handleAutoGenerate = async (title: string, keyword: string, mode: 'noun' | 'poetic', generations: number = 2) => {
    console.log('üöÄ Starting handleAutoGenerate with:', { title, keyword, mode, generations });
    
    setShowTitleModal(false);
    setIsGenerating(true);
    setGenerationProgress('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÅÆËá™ÂãïÁîüÊàê„ÇíÈñãÂßã„Åó„Å¶„ÅÑ„Åæ„Åô...');
    
    try {
      // ‰∏ñ‰ª£Êï∞„Éô„Éº„Çπ„ÅÆÈöéÂ±§ÊßãÈÄ†„Éá„Éº„Çø„Çí‰ΩúÊàê
      interface GenerationNode {
        word: string;
        id: string;
        generation: number;
        parentId?: string;
        children?: GenerationNode[];
      }

      // ‰∏ñ‰ª£Âà•ÈÄ£ÊÉ≥Ë™ûAPI„Çí‰ΩøÁî®„Åô„ÇãÈñ¢Êï∞
      const fetchGenerationalAssociations = async (keyword: string, generation: number) => {
        console.log(`üîç Fetching generational associations for keyword: "${keyword}" (generation: ${generation})`);
        
        try {
          const response = await fetch('http://localhost:5001/associate-generations', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              key: keyword,
              generation: generation
            }),
          });

          console.log(`üì° API Response status: ${response.status} ${response.statusText}`);

          const data = await response.json();
          console.log('üì¶ Raw generational API data:', data);

          // API„Çµ„Éº„Éê„Éº„Åå„Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åó„ÅüÂ†¥Âêà
          if (data.error) {
            throw new Error(`APIÂÜÖÈÉ®„Ç®„É©„Éº: ${data.message || data.error}`);
          }

          if (!response.ok) {
            throw new Error(`API„Ç®„É©„Éº (${response.status}): ${response.statusText}`);
          }

          return data;
        } catch (fetchError) {
          console.error(`‚ùå Error in fetchGenerationalAssociations for keyword "${keyword}":`, fetchError);
          throw fetchError;
        }
      };

      // ÂæìÊù•„ÅÆAPI„Åã„ÇâÈÄ£ÊÉ≥Ë™û„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞Ôºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
      const fetchAssociations = async (word: string, count: number) => {
        console.log(`üîç Fetching associations for word: "${word}" (count: ${count})`);
        
        try {
          const response = await fetch('http://localhost:5001/associate', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              word: word,
              topn: count
            }),
          });

          console.log(`üì° API Response status: ${response.status} ${response.statusText}`);

          const data = await response.json();
          console.log('üì¶ Raw API data:', data);
        
        // API„Çµ„Éº„Éê„Éº„Åå„Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åó„ÅüÂ†¥Âêà
        if (data.error) {
          throw new Error(`APIÂÜÖÈÉ®„Ç®„É©„Éº: ${data.message || data.error}`);
        }

        if (!response.ok) {
          throw new Error(`API„Ç®„É©„Éº (${response.status}): ${response.statusText}`);
        }

        console.log('üîó API Response:', {
          word: word,
          topn: count,
          associated_words: data.associated_words || data.similar_words || data || []
        });
        
        // „É¨„Çπ„Éù„É≥„Çπ„ÅåÈÖçÂàó„ÅÆÂ†¥Âêà„Å®„ÄÅassociated_words„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÊåÅ„Å§Â†¥Âêà„ÅÆ‰∏°Êñπ„Å´ÂØæÂøú
        let rawResult = Array.isArray(data) ? data : (data.associated_words || data.similar_words || data.words || []);
        
        // Á©∫„ÅÆÁµêÊûú„ÅÆÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
        if (!rawResult || rawResult.length === 0) {
          console.warn(`‚ö†Ô∏è ÂçòË™û„Äå${word}„Äç„ÅÆÈÄ£ÊÉ≥Ë™û„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü`);
          return [];
        }
        
        // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂΩ¢Âºè„ÅÆÂ†¥ÂêàÔºà{word: "ÂçòË™û", similarity: 0.5}Ôºâ„ÇíÊñáÂ≠óÂàó„Å´Â§âÊèõ
        const result = rawResult.map((item: any) => {
          if (typeof item === 'string') {
            return item;
          } else if (typeof item === 'object' && item !== null) {
            return item.word || item.text || String(item);
          }
          return String(item);
        });
        
        console.log(`‚úÖ Processed ${result.length} associations for "${word}":`, result);
        
        return result;
        } catch (fetchError) {
          console.error(`‚ùå Error in fetchAssociations for word "${word}":`, fetchError);
          throw fetchError;
        }
      };

      // ‰∏ñ‰ª£Âà•API„Çí‰ΩøÁî®„Åó„ÅüÈöéÂ±§ÊßãÈÄ†ÊßãÁØâ
      const buildGenerationTreeWithAPI = async (): Promise<GenerationNode[]> => {
        console.log('üå≥ Building generation tree with generational API...');
        let nodeCounter = 1;
        const allNodes: GenerationNode[] = [];

        // Á¨¨1‰∏ñ‰ª£Ôºà„Ç≠„Éº„ÉØ„Éº„ÉâÔºâ
        const rootNode: GenerationNode = {
          word: keyword,
          id: nodeCounter.toString(),
          generation: 1,
          children: []
        };
        allNodes.push(rootNode);
        nodeCounter++;

        try {
          // ‰∏ñ‰ª£Âà•API„ÇíÂëº„Å≥Âá∫„Åó
          const apiResponse = await fetchGenerationalAssociations(keyword, generations);
          
          if (generations === 2) {
            // ‰∏ñ‰ª£Êï∞2„ÅÆÂ†¥Âêà
            setGenerationProgress('Á¨¨2‰∏ñ‰ª£„ÅÆÈÄ£ÊÉ≥Ë™û„ÇíÂá¶ÁêÜ‰∏≠...');
            
            if (apiResponse.words && apiResponse.words.length > 0) {
              apiResponse.words.forEach((wordObj: any) => {
                const childNode: GenerationNode = {
                  word: wordObj.word,
                  id: nodeCounter.toString(),
                  generation: 2,
                  parentId: rootNode.id,
                  children: []
                };
                allNodes.push(childNode);
                nodeCounter++;
              });
            }
          } else if (generations === 3) {
            // ‰∏ñ‰ª£Êï∞3„ÅÆÂ†¥Âêà
            setGenerationProgress('Á¨¨2‰∏ñ‰ª£„ÅÆÈÄ£ÊÉ≥Ë™û„ÇíÂá¶ÁêÜ‰∏≠...');
            
            if (apiResponse.first_level && apiResponse.first_level.length > 0) {
              // Á¨¨2‰∏ñ‰ª£„ÅÆ„Éé„Éº„Éâ„Çí‰ΩúÊàê
              const secondGenNodes: GenerationNode[] = [];
              apiResponse.first_level.forEach((wordObj: any) => {
                const childNode: GenerationNode = {
                  word: wordObj.word,
                  id: nodeCounter.toString(),
                  generation: 2,
                  parentId: rootNode.id,
                  children: []
                };
                allNodes.push(childNode);
                secondGenNodes.push(childNode);
                nodeCounter++;
              });

              // Á¨¨3‰∏ñ‰ª£„ÅÆ„Éé„Éº„Éâ„Çí‰ΩúÊàê
              setGenerationProgress('Á¨¨3‰∏ñ‰ª£„ÅÆÈÄ£ÊÉ≥Ë™û„ÇíÂá¶ÁêÜ‰∏≠...');
              if (apiResponse.second_level) {
                secondGenNodes.forEach((parentNode) => {
                  const secondLevelWords = apiResponse.second_level[parentNode.word];
                  if (secondLevelWords && secondLevelWords.length > 0) {
                    secondLevelWords.forEach((wordObj: any) => {
                      const childNode: GenerationNode = {
                        word: wordObj.word,
                        id: nodeCounter.toString(),
                        generation: 3,
                        parentId: parentNode.id,
                        children: []
                      };
                      allNodes.push(childNode);
                      nodeCounter++;
                    });
                  }
                });
              }
            }
          }

          console.log(`‚úÖ Generated ${allNodes.length} nodes using generational API`);
          return allNodes;
          
        } catch (error) {
          console.warn('‚ö†Ô∏è Generational API failed, falling back to traditional method:', error);
          // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶ÂæìÊù•„ÅÆÊñπÊ≥ï„Çí‰ΩøÁî®
          return await buildGenerationTreeTraditional();
        }
      };

      // ÂæìÊù•„ÅÆÈöéÂ±§ÊßãÈÄ†ÊßãÁØâÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
      const buildGenerationTreeTraditional = async (): Promise<GenerationNode[]> => {
        console.log('üå≥ Building generation tree with traditional method...');
        let nodeCounter = 1;
        const allNodes: GenerationNode[] = [];

        // Á¨¨1‰∏ñ‰ª£Ôºà„Ç≠„Éº„ÉØ„Éº„ÉâÔºâ
        const rootNode: GenerationNode = {
          word: keyword,
          id: nodeCounter.toString(),
          generation: 1,
          children: []
        };
        allNodes.push(rootNode);
        nodeCounter++;

        if (generations >= 2) {
          // Á¨¨2‰∏ñ‰ª£Ôºà„Ç≠„Éº„ÉØ„Éº„Éâ„Åã„Çâ8„Å§„ÅÆÈÄ£ÊÉ≥Ë™ûÔºâ
          setGenerationProgress('Á¨¨2‰∏ñ‰ª£„ÅÆÈÄ£ÊÉ≥Ë™û„ÇíÁîüÊàê‰∏≠...');
          const secondGenWords = await fetchAssociations(keyword, 8);
          if (secondGenWords.length === 0) {
            throw new Error('Á¨¨2‰∏ñ‰ª£„ÅÆÈÄ£ÊÉ≥Ë™û„ÅåÁîüÊàê„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ');
          }

          for (const word of secondGenWords) {
            const childNode: GenerationNode = {
              word: word,
              id: nodeCounter.toString(),
              generation: 2,
              parentId: rootNode.id,
              children: []
            };
            allNodes.push(childNode);
            rootNode.children!.push(childNode);
            nodeCounter++;
          }

          if (generations === 3) {
            // Á¨¨3‰∏ñ‰ª£ÔºàÂêÑÈÄ£ÊÉ≥Ë™û„Åã„Çâ„Åï„Çâ„Å´3„Å§„Åö„Å§„ÅÆÈÄ£ÊÉ≥Ë™ûÔºâ
            setGenerationProgress('Á¨¨3‰∏ñ‰ª£„ÅÆÈÄ£ÊÉ≥Ë™û„ÇíÁîüÊàê‰∏≠...');
            const previousGenNodes = allNodes.filter(node => node.generation === 2);
            
            for (const parentNode of previousGenNodes) {
              try {
                const childWords = await fetchAssociations(parentNode.word, 3);
                
                for (const word of childWords) {
                  const childNode: GenerationNode = {
                    word: word,
                    id: nodeCounter.toString(),
                    generation: 3,
                    parentId: parentNode.id,
                    children: []
                  };
                  allNodes.push(childNode);
                  parentNode.children!.push(childNode);
                  nodeCounter++;
                }
              } catch (error) {
                // ÂÄãÂà•„ÅÆÂ§±Êïó„ÅØÁÑ°Ë¶ñ„Åó„Å¶Á∂öË°å
              }
            }
          }
        }

        return allNodes;
      };

      const generationNodes = await buildGenerationTreeWithAPI();
      
      if (generationNodes.length === 0) {
        throw new Error('ÈÄ£ÊÉ≥Ë™û„ÅåÁîüÊàê„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÂ§âÊõ¥„Åó„Å¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
      }
      
      setGenerationProgress('„Éé„Éº„Éâ„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíÊúÄÈÅ©Âåñ‰∏≠...');
      
      // È´òÂ∫¶„Å™Ë°ùÁ™ÅÊ§úÂá∫„Å®„É¨„Ç§„Ç¢„Ç¶„ÉàÊúÄÈÅ©Âåñ„Ç∑„Çπ„ÉÜ„É†
      
      // „Ç®„ÉÉ„Ç∏„ÅÆ‰∫§Â∑Æ„ÇíÊ§úÂá∫„Åô„ÇãÈñ¢Êï∞ÔºàÊîπËâØÁâàÔºâ
      const doLinesIntersect = (line1: { start: { x: number, y: number }, end: { x: number, y: number } }, 
                               line2: { start: { x: number, y: number }, end: { x: number, y: number } }) => {
        const { start: p1, end: p2 } = line1;
        const { start: p3, end: p4 } = line2;
        
        const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        if (Math.abs(denominator) < 0.0001) return false;
        
        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
        
        return ua >= 0.01 && ua <= 0.99 && ub >= 0.01 && ub <= 0.99; // Á´ØÁÇπËøë„Åè„ÅÆ‰∫§Â∑Æ„ÅØÁÑ°Ë¶ñ
      };

      // „Ç®„ÉÉ„Ç∏„Å®„Éé„Éº„Éâ„ÅÆË°ùÁ™ÅÊ§úÂá∫
      const doesEdgeIntersectNode = (edgeLine: { start: { x: number, y: number }, end: { x: number, y: number } }, 
                                    node: { position: { x: number, y: number } }, nodeWidth = 100, nodeHeight = 50) => {
        const { start, end } = edgeLine;
        const nodeRect = {
          left: node.position.x - 10, // „Éé„Éº„ÉâÂ¢ÉÁïå„Å´„Éû„Éº„Ç∏„É≥„ÇíËøΩÂä†
          right: node.position.x + nodeWidth + 10,
          top: node.position.y - 10,
          bottom: node.position.y + nodeHeight + 10
        };
        
        // Á∑öÂàÜ„Å®Áü©ÂΩ¢„ÅÆ‰∫§Â∑ÆÂà§ÂÆö
        const lineLength = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
        const steps = Math.ceil(lineLength / 5); // 5pxÈñìÈöî„Åß„ÉÅ„Çß„ÉÉ„ÇØ
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.x + (end.x - start.x) * t;
          const y = start.y + (end.y - start.y) * t;
          
          if (x >= nodeRect.left && x <= nodeRect.right && y >= nodeRect.top && y <= nodeRect.bottom) {
            return true;
          }
        }
        return false;
      };

      // „Éé„Éº„Éâ‰ΩçÁΩÆ„Åã„ÇâÂÆüÈöõ„ÅÆ„Ç®„ÉÉ„Ç∏„É©„Ç§„É≥ÊÉÖÂ†±„ÇíË®àÁÆóÔºàÊîπËâØÁâàÔºâ
      const getEdgeLine = (sourceNode: any, targetNode: any) => {
        const nodeWidth = 100, nodeHeight = 50;
        const sourceCenter = {
          x: sourceNode.position.x + nodeWidth / 2,
          y: sourceNode.position.y + nodeHeight / 2
        };
        const targetCenter = {
          x: targetNode.position.x + nodeWidth / 2,
          y: targetNode.position.y + nodeHeight / 2
        };
        
        return { start: sourceCenter, end: targetCenter };
      };

      // Á≠âÈñìÈöîÈÖçÁΩÆ„Å´ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Çπ„Ç≥„Ç¢Ë®àÁÆó
      const calculateLayoutScore = (newNode: any, newEdge: any, existingNodes: any[], existingEdges: any[]) => {
        let score = 0;
        const testNodes = [...existingNodes, newNode];
        
        // „Ç®„ÉÉ„Ç∏‰∫§Â∑Æ„Éö„Éä„É´„ÉÜ„Ç£ (Áµ∂ÂØæÂÑ™ÂÖà)
        const intersections = countEdgeIntersections(newEdge, existingEdges, testNodes);
        score -= intersections * 2000; // „Çà„ÇäÈ´ò„ÅÑ„Éö„Éä„É´„ÉÜ„Ç£
        
        // „Ç®„ÉÉ„Ç∏-„Éé„Éº„ÉâË°ùÁ™Å„Éö„Éä„É´„ÉÜ„Ç£ (Áµ∂ÂØæÂÑ™ÂÖà)
        const sourceNode = testNodes.find(n => n.id === newEdge.source);
        if (sourceNode) {
          const edgeLine = getEdgeLine(sourceNode, newNode);
          for (const node of existingNodes) {
            if (node.id !== sourceNode?.id && node.id !== newNode.id) {
              if (doesEdgeIntersectNode(edgeLine, node)) {
                score -= 1500; // „Çà„ÇäÈ´ò„ÅÑ„Éö„Éä„É´„ÉÜ„Ç£
              }
            }
          }
        }
        
        // „Ç®„ÉÉ„Ç∏Èï∑ÊúÄÈÅ©Âåñ (Áü≠„ÅÑÊñπ„ÅåËâØ„ÅÑ)
        if (sourceNode) {
          const edgeLength = Math.sqrt(
            (newNode.position.x + 50 - sourceNode.position.x - 50) ** 2 + 
            (newNode.position.y + 25 - sourceNode.position.y - 25) ** 2
          );
          score -= edgeLength * 1.5; // „Ç®„ÉÉ„Ç∏Èï∑„ÇíÈáçË¶ñ
        }
        
        // Á≠âÈñìÈöîÊÄß„Éú„Éº„Éä„Çπ (Âêå‰∏ñ‰ª£ÂÜÖ„Åß„ÅÆÂùáÁ≠âÂàÜÊï£)
        const sameGenerationNodes = testNodes.filter(n => n.generation === newNode.generation);
        if (sameGenerationNodes.length > 1) {
          // Âêå‰∏ñ‰ª£„Éé„Éº„ÉâÈñì„ÅÆËßíÂ∫¶„ÅÆÂùáÁ≠âÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          const angles = sameGenerationNodes.map(node => {
            return Math.atan2(node.position.y + 25, node.position.x + 50) * 180 / Math.PI;
          });
          
          angles.sort((a, b) => a - b);
          const angleGaps = [];
          for (let i = 0; i < angles.length; i++) {
            const nextAngle = angles[(i + 1) % angles.length];
            let gap = nextAngle - angles[i];
            if (gap < 0) gap += 360;
            angleGaps.push(gap);
          }
          
          const idealGap = 360 / angles.length;
          const gapVariance = angleGaps.reduce((sum, gap) => sum + Math.abs(gap - idealGap), 0);
          score -= gapVariance * 2; // Á≠âÈñìÈöî„Åã„Çâ„ÅÆÂÅèÂ∑Æ„Çí„Éö„Éä„É©„Ç§„Ç∫
        }
        
        // ÊúÄÂ∞è„Éé„Éº„ÉâÈñìË∑ùÈõ¢„Éú„Éº„Éä„Çπ
        let minDistance = Infinity;
        for (const node of existingNodes) {
          if (node.id !== newNode.id) {
            const distance = Math.sqrt(
              (newNode.position.x - node.position.x) ** 2 + 
              (newNode.position.y - node.position.y) ** 2
            );
            minDistance = Math.min(minDistance, distance);
          }
        }
        
        const idealMinDistance = 110; // „Éé„Éº„ÉâÂπÖ + „Éû„Éº„Ç∏„É≥
        if (minDistance < idealMinDistance) {
          score -= (idealMinDistance - minDistance) * 10; // Ëøë„Åô„Åé„ÇãÂ†¥Âêà„ÅÆÂ§ß„Åç„Å™„Éö„Éä„É´„ÉÜ„Ç£
        } else if (minDistance > idealMinDistance * 1.5) {
          score -= (minDistance - idealMinDistance * 1.5) * 0.5; // ÈÅ†„Åô„Åé„ÇãÂ†¥Âêà„ÅÆËªΩ„ÅÑ„Éö„Éä„É´„ÉÜ„Ç£
        }
        
        return score;
      };

      // „Ç®„ÉÉ„Ç∏‰∫§Â∑ÆÊï∞„Çí„Ç´„Ç¶„É≥„Éà„Åô„ÇãÈñ¢Êï∞ÔºàÊîπËâØÁâàÔºâ
      const countEdgeIntersections = (newEdge: any, existingEdges: any[], allNodes: any[]) => {
        const sourceNode = allNodes.find(n => n.id === newEdge.source);
        const targetNode = allNodes.find(n => n.id === newEdge.target);
        
        if (!sourceNode || !targetNode) return 0;
        
        const newLine = getEdgeLine(sourceNode, targetNode);
        let intersections = 0;
        
        for (const edge of existingEdges) {
          if (edge.source === newEdge.source || edge.target === newEdge.target || 
              edge.source === newEdge.target || edge.target === newEdge.source) continue;
              
          const edgeSource = allNodes.find(n => n.id === edge.source);
          const edgeTarget = allNodes.find(n => n.id === edge.target);
          
          if (edgeSource && edgeTarget) {
            const existingLine = getEdgeLine(edgeSource, edgeTarget);
            if (doLinesIntersect(newLine, existingLine)) {
              intersections++;
            }
          }
        }
        
        return intersections;
      };

      // ‰∏ñ‰ª£„Åî„Å®„ÅÆ„Éé„Éº„ÉâÈÖçÁΩÆ„ÇíË®àÁÆó
      const calculateGenerationLayout = (nodes: GenerationNode[]) => {
        const reactFlowNodes: any[] = [];
        const reactFlowEdges: any[] = [];
        
        // Êñ∞„Åó„ÅÑÂÜÜÂΩ¢„É¨„Ç§„Ç¢„Ç¶„Éà„Ç∑„Çπ„ÉÜ„É†
        const nodesByGeneration = nodes.reduce((acc, node) => {
          if (!acc[node.generation]) acc[node.generation] = [];
          acc[node.generation].push(node);
          return acc;
        }, {} as Record<number, GenerationNode[]>);

        const maxGeneration = Math.max(...Object.keys(nodesByGeneration).map(Number));
        
        // Á≠âÈñìÈöîÈÖçÁΩÆ„ÅÆ„Åü„ÇÅ„ÅÆÂçäÂæÑË®àÁÆó„Ç∑„Çπ„ÉÜ„É†
        const calculateUniformRadii = () => {
          const radii: Record<number, number> = {};
          const baseRadialStep = 120; // ‰∏ñ‰ª£Èñì„ÅÆÂõ∫ÂÆöË∑ùÈõ¢ÔºàÁü≠„ÅÑ„Ç®„ÉÉ„Ç∏„ÇíÂÆüÁèæÔºâ
          
          for (let gen = 1; gen <= maxGeneration; gen++) {
            if (gen === 1) {
              radii[gen] = 0; // ‰∏≠ÂøÉ
            } else {
              const nodeCount = nodesByGeneration[gen]?.length || 0;
              if (nodeCount === 0) continue;
              
              // Á≠âÈñìÈöî„Å´ÂøÖË¶Å„Å™ÊúÄÂ∞èÂçäÂæÑ„ÇíË®àÁÆó
              const nodeWidth = 110; // „Éé„Éº„ÉâÂπÖ + „Éû„Éº„Ç∏„É≥
              const minCircumference = nodeCount * nodeWidth;
              const minRadius = minCircumference / (2 * Math.PI);
              
              // Ââç‰∏ñ‰ª£„Åã„Çâ„ÅÆÊúÄÂ∞èË∑ùÈõ¢„Å®Á≠âÈñìÈöîË¶Å‰ª∂„ÅÆ‰∏°Êñπ„ÇíÊ∫Ä„Åü„Åô
              const prevRadius = radii[gen - 1] || 0;
              const minRadiusFromPrev = prevRadius + baseRadialStep;
              
              radii[gen] = Math.max(minRadius, minRadiusFromPrev);
            }
          }
          
          return radii;
        };
        
        const uniformRadii = calculateUniformRadii();

        // Á≠âÈñìÈöîÈÖçÁΩÆ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
        const calculateUniformAngles = (nodeCount: number, startAngle = 0) => {
          const angles: number[] = [];
          const angleStep = 360 / nodeCount;
          
          for (let i = 0; i < nodeCount; i++) {
            angles.push(startAngle + (i * angleStep));
          }
          
          return angles;
        };

        // Á≠âÈñìÈöîÈÖçÁΩÆ„Ç¢„É´„Ç¥„É™„Ç∫„É†
        Object.entries(nodesByGeneration)
          .sort(([a], [b]) => parseInt(a) - parseInt(b))
          .forEach(([genStr, genNodes]) => {
            const generation = parseInt(genStr);
            const radius = uniformRadii[generation];
            
            if (generation === 1) {
              // Á¨¨1‰∏ñ‰ª£Ôºà‰∏≠ÂøÉ„Éé„Éº„ÉâÔºâ
              const centerNode = {
                id: genNodes[0].id,
                type: 'customNode',
                data: { 
                  label: genNodes[0].word, 
                  isNew: false,
                  generation: genNodes[0].generation 
                },
                position: { x: -50, y: -25 },
              };
              reactFlowNodes.push(centerNode);
            } else if (generation === 2) {
              // Á¨¨2‰∏ñ‰ª£Ôºö‰∏≠ÂøÉÂë®„Çä„Å´ÂÆåÂÖ®Á≠âÈñìÈöîÈÖçÁΩÆ
              const uniformAngles = calculateUniformAngles(genNodes.length);
              
              genNodes.forEach((node, index) => {
                const angle = uniformAngles[index];
                const angleRad = angle * (Math.PI / 180);
                
                const position = {
                  x: Math.sin(angleRad) * radius - 50,
                  y: -Math.cos(angleRad) * radius - 25,
                };
                
                const reactFlowNode = {
                  id: node.id,
                  type: 'customNode',
                  data: { 
                    label: node.word, 
                    isNew: false,
                    generation: node.generation 
                  },
                  position: position,
                };
                reactFlowNodes.push(reactFlowNode);
                
                // „Ç®„ÉÉ„Ç∏„Çí‰ΩúÊàê
                if (node.parentId) {
                  const edge = {
                    id: `e${node.parentId}-${node.id}`,
                    source: node.parentId,
                    target: node.id,
                    sourceHandle: 'right',
                    targetHandle: 'left',
                  };
                  reactFlowEdges.push(edge);
                }
              });
            } else {
              // Á¨¨3‰∏ñ‰ª£‰ª•ÈôçÔºöË¶™„Ç∞„É´„Éº„Éó„Åî„Å®„Å´Á≠âÈñìÈöîÈÖçÁΩÆ
              const parentGroups = genNodes.reduce((groups, node) => {
                const parentId = node.parentId!;
                if (!groups[parentId]) groups[parentId] = [];
                groups[parentId].push(node);
                return groups;
              }, {} as Record<string, GenerationNode[]>);
              
              Object.entries(parentGroups).forEach(([parentId, children]) => {
                const parentNode = reactFlowNodes.find(n => n.id === parentId);
                if (!parentNode) return;
                
                // Ë¶™„ÅÆËßíÂ∫¶„ÇíÂü∫Ê∫ñ„Å´Â≠ê„Éé„Éº„Éâ„ÅÆÈÖçÁΩÆ„Çª„ÇØ„Çø„Éº„ÇíÊ±∫ÂÆö
                const parentAngle = Math.atan2(
                  parentNode.position.y + 25, 
                  parentNode.position.x + 50
                ) * 180 / Math.PI;
                
                // Ë°ùÁ™ÅÂõûÈÅø„ÅÆ„Åü„ÇÅ„ÅÆÊúÄÈÅ©ÈÖçÁΩÆ„ÇíÊé¢Á¥¢
                const findCollisionFreePositions = () => {
                  const childCount = children.length;
                  let bestPositions: { position: { x: number, y: number }, angle: number }[] = [];
                  let bestScore = -Infinity;
                  
                  // Ë§áÊï∞„ÅÆÈÖçÁΩÆ„Éë„Çø„Éº„É≥„ÇíË©¶Ë°å
                  for (let sectorOffset = 0; sectorOffset < 360; sectorOffset += 30) {
                    const sectorAngle = parentAngle + sectorOffset;
                    let positions: { position: { x: number, y: number }, angle: number }[] = [];
                    let totalScore = 0;
                    
                    if (childCount === 1) {
                      // Âçò‰∏ÄÂ≠ê„Éé„Éº„ÉâÔºöË¶™„ÅÆÊñπÂêë„Å´ÈÖçÁΩÆ
                      const angle = sectorAngle;
                      const angleRad = angle * (Math.PI / 180);
                      const position = {
                        x: Math.sin(angleRad) * radius - 50,
                        y: -Math.cos(angleRad) * radius - 25,
                      };
                      positions.push({ position, angle });
                    } else {
                      // Ë§áÊï∞Â≠ê„Éé„Éº„ÉâÔºö„Çª„ÇØ„Çø„ÉºÂÜÖ„Å´Á≠âÈñìÈöîÈÖçÁΩÆ
                      const sectorWidth = Math.min(60, 360 / Math.max(1, genNodes.length / 2)); // ÈÅ©ÂøúÁöÑ„Çª„ÇØ„Çø„ÉºÂπÖ
                      const startAngle = sectorAngle - (sectorWidth / 2);
                      const angleStep = sectorWidth / Math.max(1, childCount - 1);
                      
                      for (let i = 0; i < childCount; i++) {
                        const angle = startAngle + (i * angleStep);
                        const angleRad = angle * (Math.PI / 180);
                        const position = {
                          x: Math.sin(angleRad) * radius - 50,
                          y: -Math.cos(angleRad) * radius - 25,
                        };
                        positions.push({ position, angle });
                      }
                    }
                    
                    // ÂêÑ‰ΩçÁΩÆ„ÅÆ„Çπ„Ç≥„Ç¢„ÇíË®àÁÆó
                    positions.forEach((pos, i) => {
                      const testNode = {
                        id: children[i].id,
                        position: pos.position,
                        generation: generation
                      };
                      
                      const testEdge = {
                        source: parentId,
                        target: children[i].id,
                      };
                      
                      const score = calculateLayoutScore(testNode, testEdge, reactFlowNodes, reactFlowEdges);
                      totalScore += score;
                    });
                    
                    if (totalScore > bestScore) {
                      bestScore = totalScore;
                      bestPositions = positions;
                    }
                  }
                  
                  return bestPositions;
                };
                
                const optimalPositions = findCollisionFreePositions();
                
                children.forEach((node, index) => {
                  const position = optimalPositions[index]?.position || { x: 0, y: 0 };
                  
                  const reactFlowNode = {
                    id: node.id,
                    type: 'customNode',
                    data: { 
                      label: node.word, 
                      isNew: false,
                      generation: node.generation 
                    },
                    position: position,
                  };
                  reactFlowNodes.push(reactFlowNode);
                  
                  // „Ç®„ÉÉ„Ç∏„Çí‰ΩúÊàê
                  const edge = {
                    id: `e${node.parentId}-${node.id}`,
                    source: node.parentId!,
                    target: node.id,
                    sourceHandle: 'right',
                    targetHandle: 'left',
                  };
                  reactFlowEdges.push(edge);
                });
              });
            }
          });
        
        return { nodes: reactFlowNodes, edges: reactFlowEdges };
      };

      const { nodes: generatedNodes, edges: generatedEdges } = calculateGenerationLayout(generationNodes);
      
      setGenerationProgress('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê‰∏≠...');
      
      // Redux„Çπ„Éà„Ç¢„Å´Áõ¥Êé•„Éá„Éº„Çø„Çí„Çª„ÉÉ„Éà
      dispatch(createAutoGeneratedMindMap({
        title: title,
        nodes: generatedNodes,
        edges: generatedEdges
      }));
      
      // Ëá™ÂãïÁîüÊàê„Éï„É©„Ç∞‰ªò„Åç„Åß„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„ÉóÁîªÈù¢„Å´ÈÅ∑Áßª
      router.push('/mindmap?autoGenerate=true');
    } catch (error: any) {
      console.error('‚ùå Ëá™ÂãïÁîüÊàê„Ç®„É©„ÉºË©≥Á¥∞:', {
        error,
        errorType: error?.constructor?.name,
        errorMessage: error?.message,
        errorStack: error?.stack
      });
      setIsGenerating(false);
      setGenerationProgress('');
      
      let errorMessage = '„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÅÆËá™ÂãïÁîüÊàê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ';
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        errorMessage = 'API„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇ\n\n‰ª•‰∏ã„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n1. w2v_associateAPI„Çµ„Éº„Éê„Éº„ÅåËµ∑Âãï„Åó„Å¶„ÅÑ„Çã„Åã\n2. „Çµ„Éº„Éê„Éº„Åå http://localhost:5001 „ÅßÂãï‰Ωú„Åó„Å¶„ÅÑ„Çã„Åã\n\nËµ∑ÂãïÊñπÊ≥ï:\nD:/training/w2v_associateAPI „Åß\n"pip install -r requirements.txt"\n"python app.py"';
      } else if (error instanceof Error) {
        if (error.message.includes('APIÂÜÖÈÉ®„Ç®„É©„Éº')) {
          errorMessage = `${error.message}\n\nAPI„Çµ„Éº„Éê„Éº„ÅÆË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n1. Word2Vec„É¢„Éá„É´„ÅåÊ≠£„Åó„ÅèË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã„Åã\n2. Êó•Êú¨Ë™û„ÅÆÂçòË™û„Éá„Éº„Çø„ÅåÂà©Áî®ÂèØËÉΩ„Åã\n3. „Çµ„Éº„Éê„Éº„É≠„Ç∞„Åß„Ç®„É©„ÉºË©≥Á¥∞„ÇíÁ¢∫Ë™ç`;
        } else {
          errorMessage = `„Ç®„É©„Éº: ${error.message}`;
        }
      }
      
      alert(errorMessage);
    }
  };

  const handleTitleModalClose = () => {
    setShowTitleModal(false);
  };

  if (loading) {
    return (
      <div className={styles.container}>
        <div className={styles.loading}>Ë™≠„ÅøËæº„Åø‰∏≠...</div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <header className={styles.header}>
        <div className={styles.headerTop}>
          <div className={styles.titleSection}>
            <h1 className={styles.title}>Lylict</h1>
            <p className={styles.subtitle}>„Ç¢„Ç§„Éá„Ç¢„ÇíÂèØË¶ñÂåñ„Åó„ÄÅÂâµÈÄ†ÊÄß„ÇíËß£„ÅçÊîæ„Å®„ÅÜ</p>
          </div>
          <LoginButton user={user} onUserChange={setUser} />
        </div>
        <button 
          onClick={handleCreateNew} 
          className={styles.createButton}
          disabled={!user}
          style={{ opacity: !user ? 0.6 : 1, cursor: !user ? 'not-allowed' : 'pointer' }}
        >
          Êñ∞„Åó„ÅÑ„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê
        </button>
      </header>

      <main className={styles.main}>
        {error && (
          <div className={styles.error}>
            <span>{error}</span>
            <button onClick={loadMindMaps} className={styles.retryButton}>
              ÂÜçË©¶Ë°å
            </button>
          </div>
        )}

        {!user ? (
          <div className={styles.empty}>
            <div className={styles.emptyIcon}>üîê</div>
            <h2>„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô</h2>
            <p>„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê„ÉªÁÆ°ÁêÜ„Åô„Çã„Å´„ÅØ„ÄÅGoogle„Ç¢„Ç´„Ç¶„É≥„Éà„Åß„É≠„Ç∞„Ç§„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
          </div>
        ) : mindMaps.length === 0 ? (
          <div className={styles.empty}>
            <div className={styles.emptyIcon}>üß†</div>
            <h2>„Åæ„Å†„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</h2>
            <p>ÊúÄÂàù„ÅÆ„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê„Åó„Å¶„ÄÅ„Ç¢„Ç§„Éá„Ç¢„ÅÆÊï¥ÁêÜ„ÇíÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ</p>
            <button onClick={handleCreateNew} className={styles.createButton}>
              ÊúÄÂàù„ÅÆ„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê
            </button>
          </div>
        ) : (
          <>
            <div className={styles.stats}>
              <span className={styles.count}>ÂêàË®à {mindMaps.length} ÂÄã„ÅÆ„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó</span>
            </div>
            <div className={styles.grid}>
              {mindMaps.map((mindMap) => (
                <div key={mindMap.id} className={styles.card}>
                  <div className={styles.cardContent}>
                    <h3 className={styles.cardTitle}>{mindMap.title}</h3>
                    <div className={styles.cardMeta}>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>„Éé„Éº„ÉâÊï∞:</span>
                        <span className={styles.metaValue}>{mindMap.nodes.length}</span>
                      </div>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>‰ΩúÊàêÊó•:</span>
                        <span className={styles.metaValue}>{formatDate(mindMap.createdAt)}</span>
                      </div>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>Êõ¥Êñ∞Êó•:</span>
                        <span className={styles.metaValue}>{formatDate(mindMap.updatedAt)}</span>
                      </div>
                    </div>
                  </div>
                  <div className={styles.cardActions}>
                    <Link 
                      href={`/mindmap?id=${mindMap.id}`} 
                      className={styles.editButton}
                    >
                      Á∑®ÈõÜ
                    </Link>
                    <button 
                      onClick={() => mindMap.id && handleDelete(mindMap.id)}
                      className={styles.deleteButton}
                    >
                      ÂâäÈô§
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </>
        )}
      </main>

      <TitleInputModal
        isOpen={showTitleModal}
        onClose={handleTitleModalClose}
        onConfirm={handleTitleConfirm}
        onAutoGenerate={handleAutoGenerate}
      />

      {/* „É≠„Éº„Éá„Ç£„É≥„Ç∞ÁîªÈù¢ */}
      {isGenerating && (
        <div className={styles.loadingOverlay}>
          <div className={styles.loadingContent}>
            <div className={styles.spinner}></div>
            <h2>„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„ÇíËá™ÂãïÁîüÊàê‰∏≠...</h2>
            <p>{generationProgress}</p>
            <div className={styles.progressBar}>
              <div className={styles.progressBarFill}></div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
