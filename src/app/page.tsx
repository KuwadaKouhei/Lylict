'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useDispatch } from 'react-redux';
import { getAllMindMaps, deleteMindMap, MindMap } from '@/lib/mindmapService';
import { AppDispatch } from '@/lib/store';
import { createAutoGeneratedMindMap } from '@/lib/features/mindmap/mindmapSlice';
import { onAuthStateChange } from '@/lib/auth';
import { User } from 'firebase/auth';
import TitleInputModal from '@/components/TitleInputModal';
import LoginButton from '@/components/LoginButton';
import { fetchGenerationalAssociations, fetchAssociations } from '@/lib/aiApiService';
import styles from './page.module.css';

export default function Home() {
  const [mindMaps, setMindMaps] = useState<MindMap[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showTitleModal, setShowTitleModal] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationProgress, setGenerationProgress] = useState('');
  const [user, setUser] = useState<User | null>(null);

  const router = useRouter();
  const dispatch: AppDispatch = useDispatch();

  useEffect(() => {
    // èªè¨¼çŠ¶æ…‹ã®ç›£è¦–
    const unsubscribe = onAuthStateChange((user) => {
      setUser(user);
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ­ã‚°ã‚¤ãƒ³ã—ãŸã‚‰ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’èª­ã¿è¾¼ã¿
      if (user) {
        loadMindMaps();
      } else {
        setMindMaps([]);
        setLoading(false); // æœªèªè¨¼ã®å ´åˆã¯ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’çµ‚äº†
      }
    });
    
    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    return () => {
      setIsGenerating(false);
      setGenerationProgress('');
      unsubscribe();
    };
  }, []);

  const loadMindMaps = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // èªè¨¼çŠ¶æ…‹ã‚’è©³ç´°ãƒã‚§ãƒƒã‚¯
      console.log('loadMindMaps å®Ÿè¡Œæ™‚ã®èªè¨¼çŠ¶æ…‹:', {
        user: user,
        uid: user?.uid,
        isAuthenticated: !!user
      });
      
      const maps = await getAllMindMaps();
      setMindMaps(maps);
    } catch (err: any) {
      console.error('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err);
      if (err.message === 'AUTHENTICATION_REQUIRED') {
        // èªè¨¼ãŒå¿…è¦ãªå ´åˆã¯ç©ºã®é…åˆ—ã‚’ã‚»ãƒƒãƒˆã—ã¦ã‚¨ãƒ©ãƒ¼ã¯è¡¨ç¤ºã—ãªã„
        setMindMaps([]);
        setError(null); // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚ã‚¯ãƒªã‚¢
      } else {
        setError('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      }
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm('ã“ã®ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
    
    try {
      await deleteMindMap(id);
      setMindMaps(mindMaps.filter(map => map.id !== id));
    } catch (err) {
      console.error('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã®å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', err);
      setError('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  };

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const handleCreateNew = () => {
    if (!user) {
      alert('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ã¾ãšãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    setShowTitleModal(true);
  };

  const handleTitleConfirm = (title: string, firstWord: string) => {
    setShowTitleModal(false);
    // ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ€åˆã®ãƒ¯ãƒ¼ãƒ‰ã‚’URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦æ¸¡ã—ã¦ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ç”»é¢ã«é·ç§»
    router.push(`/mindmap?title=${encodeURIComponent(title)}&firstWord=${encodeURIComponent(firstWord)}`);
  };

  const handleAutoGenerate = async (title: string, keyword: string, mode: 'noun' | 'poetic', generations: number = 2) => {
    setShowTitleModal(false);
    setIsGenerating(true);
    setGenerationProgress('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã®è‡ªå‹•ç”Ÿæˆã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...');
    
    try {
      // ä¸–ä»£æ•°ãƒ™ãƒ¼ã‚¹ã®éšå±¤æ§‹é€ ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
      interface GenerationNode {
        word: string;
        id: string;
        generation: number;
        parentId?: string;
        children?: GenerationNode[];
      }

      // ä¸–ä»£åˆ¥APIã‚’ä½¿ç”¨ã—ãŸéšå±¤æ§‹é€ æ§‹ç¯‰
      const buildGenerationTreeWithAPI = async (): Promise<GenerationNode[]> => {
        let nodeCounter = 1;
        const allNodes: GenerationNode[] = [];

        // ç¬¬1ä¸–ä»£ï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰
        const rootNode: GenerationNode = {
          word: keyword,
          id: nodeCounter.toString(),
          generation: 1,
          children: []
        };
        allNodes.push(rootNode);
        nodeCounter++;

        try {
          // ä¸–ä»£åˆ¥APIã‚’å‘¼ã³å‡ºã—ï¼ˆaiApiService.tsã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼‰
          setGenerationProgress(`${generations}ä¸–ä»£ã®é€£æƒ³èªã‚’ç”Ÿæˆä¸­...`);
          const apiResponse = await fetchGenerationalAssociations(keyword, generations);
          
          if (apiResponse.status === 'error') {
            throw new Error(`API ã‚¨ãƒ©ãƒ¼: ${apiResponse.message}`);
          }

          if (apiResponse.generations && apiResponse.generations.length > 0) {
            // å„ä¸–ä»£ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†
            setGenerationProgress(`é€£æƒ³èªãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­... (${apiResponse.generations.length}å€‹ã®ä¸–ä»£ãƒ‡ãƒ¼ã‚¿)`);
            
            // ä¸–ä»£ã”ã¨ã«å‡¦ç†
            apiResponse.generations.forEach((genData: import('@/lib/aiApiService').GenerationResult) => {
              if (genData.generation_number === 2) {
                // ç¬¬2ä¸–ä»£ï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰ã®ç›´æ¥é€£æƒ³èªï¼‰
                genData.results.forEach((wordObj: import('@/lib/aiApiService').AssociationWord) => {
                  const childNode: GenerationNode = {
                    word: wordObj.word,
                    id: nodeCounter.toString(),
                    generation: 2,
                    parentId: rootNode.id,
                    children: []
                  };
                  allNodes.push(childNode);
                  rootNode.children!.push(childNode);
                  nodeCounter++;
                });
              } else if (genData.generation_number === 3) {
                // ç¬¬3ä¸–ä»£ï¼ˆç¬¬2ä¸–ä»£ã®å„èªã‹ã‚‰ã®é€£æƒ³èªï¼‰
                const parentNode = allNodes.find(node => 
                  node.generation === 2 && node.word === genData.parent_word
                );
                
                if (parentNode) {
                  genData.results.forEach((wordObj: import('@/lib/aiApiService').AssociationWord) => {
                    const childNode: GenerationNode = {
                      word: wordObj.word,
                      id: nodeCounter.toString(),
                      generation: 3,
                      parentId: parentNode.id,
                      children: []
                    };
                    allNodes.push(childNode);
                    parentNode.children!.push(childNode);
                    nodeCounter++;
                  });
                } else {
                  console.warn(`âš ï¸ ç¬¬3ä¸–ä»£ã®è¦ªãƒãƒ¼ãƒ‰ã€Œ${genData.parent_word}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                }
              }
            });
            
          }

          return allNodes;
          
        } catch (error) {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦å¾“æ¥ã®æ–¹æ³•ã‚’ä½¿ç”¨
          return await buildGenerationTreeTraditional();
        }
      };

      // å¾“æ¥ã®éšå±¤æ§‹é€ æ§‹ç¯‰ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
      const buildGenerationTreeTraditional = async (): Promise<GenerationNode[]> => {
        let nodeCounter = 1;
        const allNodes: GenerationNode[] = [];

        // ç¬¬1ä¸–ä»£ï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰
        const rootNode: GenerationNode = {
          word: keyword,
          id: nodeCounter.toString(),
          generation: 1,
          children: []
        };
        allNodes.push(rootNode);
        nodeCounter++;

        if (generations >= 2) {
          // ç¬¬2ä¸–ä»£ï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰8ã¤ã®é€£æƒ³èªï¼‰
          setGenerationProgress('ç¬¬2ä¸–ä»£ã®é€£æƒ³èªã‚’ç”Ÿæˆä¸­...');
          const secondGenWords = await fetchAssociations(keyword, 8);
          if (secondGenWords.length === 0) {
            throw new Error('ç¬¬2ä¸–ä»£ã®é€£æƒ³èªãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚');
          }

          for (const word of secondGenWords) {
            const childNode: GenerationNode = {
              word: word,
              id: nodeCounter.toString(),
              generation: 2,
              parentId: rootNode.id,
              children: []
            };
            allNodes.push(childNode);
            rootNode.children!.push(childNode);
            nodeCounter++;
          }

          if (generations === 3) {
            // ç¬¬3ä¸–ä»£ï¼ˆå„é€£æƒ³èªã‹ã‚‰ã•ã‚‰ã«3ã¤ãšã¤ã®é€£æƒ³èªï¼‰
            setGenerationProgress('ç¬¬3ä¸–ä»£ã®é€£æƒ³èªã‚’ç”Ÿæˆä¸­...');
            const previousGenNodes = allNodes.filter(node => node.generation === 2);
            
            for (const parentNode of previousGenNodes) {
              try {
                const childWords = await fetchAssociations(parentNode.word, 3);
                
                for (const word of childWords) {
                  const childNode: GenerationNode = {
                    word: word,
                    id: nodeCounter.toString(),
                    generation: 3,
                    parentId: parentNode.id,
                    children: []
                  };
                  allNodes.push(childNode);
                  parentNode.children!.push(childNode);
                  nodeCounter++;
                }
              } catch (error) {
                // å€‹åˆ¥ã®å¤±æ•—ã¯ç„¡è¦–ã—ã¦ç¶šè¡Œ
              }
            }
          }
        }

        return allNodes;
      };

      const generationNodes = await buildGenerationTreeWithAPI();
      
      if (generationNodes.length === 0) {
        throw new Error('é€£æƒ³èªãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      }
      
      setGenerationProgress('ãƒãƒ¼ãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æœ€é©åŒ–ä¸­...');
      
      // é«˜åº¦ãªè¡çªæ¤œå‡ºã¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ 
      
      // ã‚¨ãƒƒã‚¸ã®äº¤å·®ã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
      const doLinesIntersect = (
        line1: { start: { x: number, y: number }, end: { x: number, y: number } }, 
        line2: { start: { x: number, y: number }, end: { x: number, y: number } }
      ) => {
        const { start: p1, end: p2 } = line1;
        const { start: p3, end: p4 } = line2;
        
        const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        if (Math.abs(denominator) < 0.0001) return false;
        
        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
        
        return ua >= 0.01 && ua <= 0.99 && ub >= 0.01 && ub <= 0.99; // ç«¯ç‚¹è¿‘ãã®äº¤å·®ã¯ç„¡è¦–
      };

      // ã‚¨ãƒƒã‚¸ã¨ãƒãƒ¼ãƒ‰ã®è¡çªæ¤œå‡º
      const doesEdgeIntersectNode = (edgeLine: { start: { x: number, y: number }, end: { x: number, y: number } }, 
                                    node: { position: { x: number, y: number } }, nodeWidth = 100, nodeHeight = 50) => {
        const { start, end } = edgeLine;
        const nodeRect = {
          left: node.position.x - 10, // ãƒãƒ¼ãƒ‰å¢ƒç•Œã«ãƒãƒ¼ã‚¸ãƒ³ã‚’è¿½åŠ 
          right: node.position.x + nodeWidth + 10,
          top: node.position.y - 10,
          bottom: node.position.y + nodeHeight + 10
        };
        
        // ç·šåˆ†ã¨çŸ©å½¢ã®äº¤å·®åˆ¤å®š
        const lineLength = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
        const steps = Math.ceil(lineLength / 5); // 5pxé–“éš”ã§ãƒã‚§ãƒƒã‚¯
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.x + (end.x - start.x) * t;
          const y = start.y + (end.y - start.y) * t;
          
          if (x >= nodeRect.left && x <= nodeRect.right && y >= nodeRect.top && y <= nodeRect.bottom) {
            return true;
          }
        }
        return false;
      };

      // ãƒãƒ¼ãƒ‰ä½ç½®ã‹ã‚‰å®Ÿéš›ã®ã‚¨ãƒƒã‚¸ãƒ©ã‚¤ãƒ³æƒ…å ±ã‚’è¨ˆç®—ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
      const getEdgeLine = (sourceNode: any, targetNode: any) => {
        const nodeWidth = 100, nodeHeight = 50;
        const sourceCenter = {
          x: sourceNode.position.x + nodeWidth / 2,
          y: sourceNode.position.y + nodeHeight / 2
        };
        const targetCenter = {
          x: targetNode.position.x + nodeWidth / 2,
          y: targetNode.position.y + nodeHeight / 2
        };
        
        return { start: sourceCenter, end: targetCenter };
      };

      // ç­‰é–“éš”é…ç½®ã«æœ€é©åŒ–ã•ã‚ŒãŸã‚¹ã‚³ã‚¢è¨ˆç®—
      const calculateLayoutScore = (newNode: any, newEdge: any, existingNodes: any[], existingEdges: any[]) => {
        let score = 0;
        const testNodes = [...existingNodes, newNode];
        
        // ã‚¨ãƒƒã‚¸äº¤å·®ãƒšãƒŠãƒ«ãƒ†ã‚£ (çµ¶å¯¾å„ªå…ˆ)
        const intersections = countEdgeIntersections(newEdge, existingEdges, testNodes);
        score -= intersections * 2000; // ã‚ˆã‚Šé«˜ã„ãƒšãƒŠãƒ«ãƒ†ã‚£
        
        // ã‚¨ãƒƒã‚¸-ãƒãƒ¼ãƒ‰è¡çªãƒšãƒŠãƒ«ãƒ†ã‚£ (çµ¶å¯¾å„ªå…ˆ)
        const sourceNode = testNodes.find(n => n.id === newEdge.source);
        if (sourceNode) {
          const edgeLine = getEdgeLine(sourceNode, newNode);
          for (const node of existingNodes) {
            if (node.id !== sourceNode?.id && node.id !== newNode.id) {
              if (doesEdgeIntersectNode(edgeLine, node)) {
                score -= 1500; // ã‚ˆã‚Šé«˜ã„ãƒšãƒŠãƒ«ãƒ†ã‚£
              }
            }
          }
        }
        
        // ã‚¨ãƒƒã‚¸é•·æœ€é©åŒ– (çŸ­ã„æ–¹ãŒè‰¯ã„)
        if (sourceNode) {
          const edgeLength = Math.sqrt(
            (newNode.position.x + 50 - sourceNode.position.x - 50) ** 2 + 
            (newNode.position.y + 25 - sourceNode.position.y - 25) ** 2
          );
          score -= edgeLength * 1.5; // ã‚¨ãƒƒã‚¸é•·ã‚’é‡è¦–
        }
        
        // ç­‰é–“éš”æ€§ãƒœãƒ¼ãƒŠã‚¹ (åŒä¸–ä»£å†…ã§ã®å‡ç­‰åˆ†æ•£)
        const sameGenerationNodes = testNodes.filter(n => n.generation === newNode.generation);
        if (sameGenerationNodes.length > 1) {
          // åŒä¸–ä»£ãƒãƒ¼ãƒ‰é–“ã®è§’åº¦ã®å‡ç­‰æ€§ã‚’ãƒã‚§ãƒƒã‚¯
          const angles = sameGenerationNodes.map(node => {
            return Math.atan2(node.position.y + 25, node.position.x + 50) * 180 / Math.PI;
          });
          
          angles.sort((a, b) => a - b);
          const angleGaps = [];
          for (let i = 0; i < angles.length; i++) {
            const nextAngle = angles[(i + 1) % angles.length];
            let gap = nextAngle - angles[i];
            if (gap < 0) gap += 360;
            angleGaps.push(gap);
          }
          
          const idealGap = 360 / angles.length;
          const gapVariance = angleGaps.reduce((sum, gap) => sum + Math.abs(gap - idealGap), 0);
          score -= gapVariance * 2; // ç­‰é–“éš”ã‹ã‚‰ã®åå·®ã‚’ãƒšãƒŠãƒ©ã‚¤ã‚º
        }
        
        // æœ€å°ãƒãƒ¼ãƒ‰é–“è·é›¢ãƒœãƒ¼ãƒŠã‚¹
        let minDistance = Infinity;
        for (const node of existingNodes) {
          if (node.id !== newNode.id) {
            const distance = Math.sqrt(
              (newNode.position.x - node.position.x) ** 2 + 
              (newNode.position.y - node.position.y) ** 2
            );
            minDistance = Math.min(minDistance, distance);
          }
        }
        
        const idealMinDistance = 110; // ãƒãƒ¼ãƒ‰å¹… + ãƒãƒ¼ã‚¸ãƒ³
        if (minDistance < idealMinDistance) {
          score -= (idealMinDistance - minDistance) * 10; // è¿‘ã™ãã‚‹å ´åˆã®å¤§ããªãƒšãƒŠãƒ«ãƒ†ã‚£
        } else if (minDistance > idealMinDistance * 1.5) {
          score -= (minDistance - idealMinDistance * 1.5) * 0.5; // é ã™ãã‚‹å ´åˆã®è»½ã„ãƒšãƒŠãƒ«ãƒ†ã‚£
        }
        
        return score;
      };

      // ã‚¨ãƒƒã‚¸äº¤å·®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹é–¢æ•°ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
      const countEdgeIntersections = (newEdge: any, existingEdges: any[], allNodes: any[]) => {
        const sourceNode = allNodes.find(n => n.id === newEdge.source);
        const targetNode = allNodes.find(n => n.id === newEdge.target);
        
        if (!sourceNode || !targetNode) return 0;
        
        const newLine = getEdgeLine(sourceNode, targetNode);
        let intersections = 0;
        
        for (const edge of existingEdges) {
          if (edge.source === newEdge.source || edge.target === newEdge.target || 
              edge.source === newEdge.target || edge.target === newEdge.source) continue;
              
          const edgeSource = allNodes.find(n => n.id === edge.source);
          const edgeTarget = allNodes.find(n => n.id === edge.target);
          
          if (edgeSource && edgeTarget) {
            const existingLine = getEdgeLine(edgeSource, edgeTarget);
            if (doLinesIntersect(newLine, existingLine)) {
              intersections++;
            }
          }
        }
        
        return intersections;
      };

      // ä¸–ä»£ã”ã¨ã®ãƒãƒ¼ãƒ‰é…ç½®ã‚’è¨ˆç®—ï¼ˆå®Œå…¨æ–°è¦å®Ÿè£…ï¼‰
      const calculateGenerationLayout = (nodes: GenerationNode[]) => {
        const reactFlowNodes: any[] = [];
        const reactFlowEdges: any[] = [];
        
        // ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã®å®šæ•°å®šç¾©
        const nodeWidth = 150;  // CustomNodeã®æ¨å®šå¹…
        const nodeHeight = 50;  // CustomNodeã®æ¨å®šé«˜ã•
        const minNodeDistance = 200; // ãƒãƒ¼ãƒ‰é–“ã®æœ€å°è·é›¢
        
        // ä¸–ä»£åˆ¥ã«ãƒãƒ¼ãƒ‰ã‚’åˆ†é¡
        const nodesByGeneration = nodes.reduce((acc, node) => {
          if (!acc[node.generation]) acc[node.generation] = [];
          acc[node.generation].push(node);
          return acc;
        }, {} as Record<number, GenerationNode[]>);

        const maxGeneration = Math.max(...Object.keys(nodesByGeneration).map(Number));
        
        // æ”¹è‰¯ã•ã‚ŒãŸå††çŠ¶é…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        const calculateOptimalLayout = () => {
          
          // å„ä¸–ä»£ã®æœ€é©åŠå¾„ã‚’è¨ˆç®—
          const calculateOptimalRadii = () => {
            const radii: Record<number, number> = {};
            
            for (let gen = 1; gen <= maxGeneration; gen++) {
              if (gen === 1) {
                radii[gen] = 0; // ä¸­å¿ƒ
              } else {
                const nodeCount = nodesByGeneration[gen]?.length || 0;
                if (nodeCount === 0) continue;
                
                // å††å‘¨ä¸Šã«é…ç½®ã™ã‚‹ãŸã‚ã«å¿…è¦ãªæœ€å°åŠå¾„ã‚’è¨ˆç®—
                // éš£æ¥ãƒãƒ¼ãƒ‰é–“ã®è·é›¢ãŒminNodeDistanceä»¥ä¸Šã«ãªã‚‹ã‚ˆã†ãªåŠå¾„
                const requiredCircumference = nodeCount * minNodeDistance;
                const minRadiusForSpacing = requiredCircumference / (2 * Math.PI);
                
                // å‰ä¸–ä»£ã‹ã‚‰ã®æœ€å°è·é›¢ï¼ˆç¬¬3ä¸–ä»£ä»¥é™ã¯é©åº¦ã«çŸ­ãï¼‰
                const prevRadius = radii[gen - 1] || 0;
                const generationGap = gen >= 3 ? minNodeDistance * 0.8 : minNodeDistance; // ç¬¬3ä¸–ä»£ä»¥é™ã¯20%çŸ­ã
                const minRadiusFromPrev = prevRadius + generationGap;
                
                // ã‚ˆã‚Šå¤§ãã„æ–¹ã‚’æ¡ç”¨
                radii[gen] = Math.max(minRadiusForSpacing, minRadiusFromPrev);
                
              }
            }
            
            return radii;
          };
          
          const optimalRadii = calculateOptimalRadii();
          
          // å„ä¸–ä»£ã®ãƒãƒ¼ãƒ‰ã‚’é…ç½®
          Object.entries(nodesByGeneration)
            .sort(([a], [b]) => parseInt(a) - parseInt(b))
            .forEach(([genStr, genNodes]) => {
              const generation = parseInt(genStr);
              const radius = optimalRadii[generation];
              
              
              if (generation === 1) {
                // ç¬¬1ä¸–ä»£ï¼ˆä¸­å¿ƒãƒãƒ¼ãƒ‰ï¼‰
                const centerNode = {
                  id: genNodes[0].id,
                  type: 'customNode',
                  data: { 
                    label: genNodes[0].word, 
                    isNew: false,
                    generation: genNodes[0].generation 
                  },
                  position: { x: -(nodeWidth / 2), y: -(nodeHeight / 2) },
                };
                reactFlowNodes.push(centerNode);
                                
              } else if (generation === 2) {
                // ç¬¬2ä¸–ä»£ï¼šä¸­å¿ƒå‘¨ã‚Šã«å®Œå…¨ç­‰é–“éš”é…ç½®ï¼ˆ90åº¦å›è»¢ï¼‰
                const nodeCount = genNodes.length;
                
                genNodes.forEach((node, index) => {
                  // 90åº¦ã‹ã‚‰é–‹å§‹ã—ã¦ç­‰é–“éš”ã«é…ç½®
                  const angle = 90 + (index * 360) / nodeCount;
                  const angleRad = (angle * Math.PI) / 180;
                  
                  // æ¥µåº§æ¨™ã‹ã‚‰ç›´äº¤åº§æ¨™ã¸ã®å¤‰æ›
                  const position = {
                    x: Math.cos(angleRad) * radius - (nodeWidth / 2),
                    y: Math.sin(angleRad) * radius - (nodeHeight / 2),
                  };
                  
                  const reactFlowNode = {
                    id: node.id,
                    type: 'customNode',
                    data: { 
                      label: node.word, 
                      isNew: false,
                      generation: node.generation 
                    },
                    position: position,
                  };
                  reactFlowNodes.push(reactFlowNode);
                                    
                  // ã‚¨ãƒƒã‚¸ã‚’ä½œæˆï¼ˆä¸­å¿ƒãƒãƒ¼ãƒ‰ã¸ã®æ¥ç¶šï¼‰
                  if (node.parentId) {
                    const edge = {
                      id: `e${node.parentId}-${node.id}`,
                      source: node.parentId,
                      target: node.id,
                      type: 'floating',
                    };
                    reactFlowEdges.push(edge);
                  }
                });
                
              } else {
                // ç¬¬3ä¸–ä»£ä»¥é™ï¼šè¦ªãƒãƒ¼ãƒ‰ã®å»¶é•·ç·šä¸Šã«æ”¾å°„çŠ¶é…ç½®
                // è¦ªãƒãƒ¼ãƒ‰ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                const parentGroups = genNodes.reduce((groups, node) => {
                  const parentId = node.parentId!;
                  if (!groups[parentId]) groups[parentId] = [];
                  groups[parentId].push(node);
                  return groups;
                }, {} as Record<string, GenerationNode[]>);
                
                Object.entries(parentGroups).forEach(([parentId, children]) => {
                  const parentNode = reactFlowNodes.find(n => n.id === parentId);
                  if (!parentNode) return;
                  
                  // è¦ªãƒãƒ¼ãƒ‰ã®ä¸­å¿ƒã‹ã‚‰è¦‹ãŸè§’åº¦ã‚’è¨ˆç®—ï¼ˆä¸­å¿ƒãƒãƒ¼ãƒ‰ã‹ã‚‰ã®æ”¾å°„è§’åº¦ï¼‰
                  const parentAngle = Math.atan2(
                    parentNode.position.y + (nodeHeight / 2), 
                    parentNode.position.x + (nodeWidth / 2)
                  );
                  
                  children.forEach((node, childIndex) => {
                    let angle = parentAngle;
                    
                    // åŒã˜è¦ªã«è¤‡æ•°ã®å­ãŒã‚ã‚‹å ´åˆã€30åº¦ç¯„å›²å†…ã§ç­‰é–“éš”ã«é…ç½®
                    if (children.length > 1) {
                      const totalAngleRange = 30; // åº¦ï¼ˆ30åº¦ç¯„å›²ã«èª¿æ•´ï¼‰
                      const angleOffset = totalAngleRange / (children.length - 1);
                      const startOffset = -totalAngleRange / 2;
                      angle = parentAngle + (startOffset + childIndex * angleOffset) * Math.PI / 180;
                    }
                    
                    // è¦ªãƒãƒ¼ãƒ‰ã®å»¶é•·ç·šä¸Šã«é…ç½®ï¼ˆä¸­å¿ƒã‹ã‚‰ã®æ”¾å°„ç·šæ–¹å‘ï¼‰
                    const position = {
                      x: Math.cos(angle) * radius - (nodeWidth / 2),
                      y: Math.sin(angle) * radius - (nodeHeight / 2),
                    };
                    
                    const reactFlowNode = {
                      id: node.id,
                      type: 'customNode',
                      data: { 
                        label: node.word, 
                        isNew: false,
                        generation: node.generation 
                      },
                      position: position,
                    };
                    reactFlowNodes.push(reactFlowNode);
                    
                    // ã‚¨ãƒƒã‚¸ã‚’ä½œæˆï¼ˆè¦ªãƒãƒ¼ãƒ‰ã¸ã®æ¥ç¶šï¼‰
                    const edge = {
                      id: `e${parentId}-${node.id}`,
                      source: parentId,
                      target: node.id,
                      type: 'floating',
                    };
                    reactFlowEdges.push(edge);
                  });
                });
              }
            });
        };
        
        calculateOptimalLayout();
                
        return { nodes: reactFlowNodes, edges: reactFlowEdges };
      };

      const { nodes: generatedNodes, edges: generatedEdges } = calculateGenerationLayout(generationNodes);
      
      setGenerationProgress('ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’ä½œæˆä¸­...');
            
      dispatch(createAutoGeneratedMindMap({
        title: title,
        nodes: generatedNodes,
        edges: generatedEdges
      }));
      
      // è‡ªå‹•ç”Ÿæˆãƒ•ãƒ©ã‚°ä»˜ãã§ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ç”»é¢ã«é·ç§»
      router.push('/mindmap?autoGenerate=true');
    } catch (error: any) {
      console.error('âŒ è‡ªå‹•ç”Ÿæˆã‚¨ãƒ©ãƒ¼è©³ç´°:', {
        error,
        errorType: error?.constructor?.name,
        errorMessage: error?.message,
        errorStack: error?.stack
      });
      setIsGenerating(false);
      setGenerationProgress('');
      
      let errorMessage = 'ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã®è‡ªå‹•ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        errorMessage = 'APIã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚\n\nä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„:\n1. æœ¬ç•ªAPIã‚µãƒ¼ãƒãƒ¼ãŒç¨¼åƒã—ã¦ã„ã‚‹ã‹\n2. ã‚µãƒ¼ãƒãƒ¼ãŒå‹•ä½œã—ã¦ã„ã‚‹ã‹\n3. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒæ­£å¸¸ã‹\n\nãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºæ™‚ã¯:\nD:/training/w2v_associateAPI ã§\n"pip install -r requirements.txt"\n"python main.py"';
      } else if (error instanceof Error) {
        if (error.message.includes('APIå†…éƒ¨ã‚¨ãƒ©ãƒ¼')) {
          errorMessage = `${error.message}\n\nAPIã‚µãƒ¼ãƒãƒ¼ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„:\n1. Word2Vecãƒ¢ãƒ‡ãƒ«ãŒæ­£ã—ãèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹\n2. æ—¥æœ¬èªã®å˜èªãƒ‡ãƒ¼ã‚¿ãŒåˆ©ç”¨å¯èƒ½ã‹\n3. ã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°ã§ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’ç¢ºèª`;
        } else {
          errorMessage = `ã‚¨ãƒ©ãƒ¼: ${error.message}`;
        }
      }
      
      alert(errorMessage);
    }
  };

  const handleTitleModalClose = () => {
    setShowTitleModal(false);
  };

  if (loading) {
    return (
      <div className={styles.container}>
        <div className={styles.loading}>èª­ã¿è¾¼ã¿ä¸­...</div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <header className={styles.header}>
        <div className={styles.headerTop}>
          <div className={styles.titleSection}>
            <h1 className={styles.title}>Lylict</h1>
            <p className={styles.subtitle}>ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å¯è¦–åŒ–ã—ã€å‰µé€ æ€§ã‚’è§£ãæ”¾ã¨ã†</p>
          </div>
          <LoginButton user={user} onUserChange={setUser} />
        </div>
        <button 
          onClick={handleCreateNew} 
          className={styles.createButton}
          disabled={!user}
          style={{ opacity: !user ? 0.6 : 1, cursor: !user ? 'not-allowed' : 'pointer' }}
        >
          æ–°ã—ã„ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’ä½œæˆ
        </button>
      </header>

      <main className={styles.main}>
        {error && (
          <div className={styles.error}>
            <span>{error}</span>
            <button onClick={loadMindMaps} className={styles.retryButton}>
              å†è©¦è¡Œ
            </button>
          </div>
        )}

        {!user ? (
          <div className={styles.empty}>
            <div className={styles.emptyIcon}>ğŸ”</div>
            <h2>ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™</h2>
            <p>ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’ä½œæˆãƒ»ç®¡ç†ã™ã‚‹ã«ã¯ã€Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„</p>
          </div>
        ) : mindMaps.length === 0 ? (
          <div className={styles.empty}>
            <div className={styles.emptyIcon}>ğŸ§ </div>
            <h2>ã¾ã ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“</h2>
            <p>æœ€åˆã®ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’ä½œæˆã—ã¦ã€ã‚¢ã‚¤ãƒ‡ã‚¢ã®æ•´ç†ã‚’å§‹ã‚ã¾ã—ã‚‡ã†</p>
            <button onClick={handleCreateNew} className={styles.createButton}>
              æœ€åˆã®ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’ä½œæˆ
            </button>
          </div>
        ) : (
          <>
            <div className={styles.stats}>
              <span className={styles.count}>åˆè¨ˆ {mindMaps.length} å€‹ã®ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—</span>
            </div>
            <div className={styles.grid}>
              {mindMaps.map((mindMap) => (
                <div key={mindMap.id} className={styles.card}>
                  <div className={styles.cardContent}>
                    <h3 className={styles.cardTitle}>{mindMap.title}</h3>
                    <div className={styles.cardMeta}>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>ãƒãƒ¼ãƒ‰æ•°:</span>
                        <span className={styles.metaValue}>{mindMap.nodes.length}</span>
                      </div>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>ä½œæˆæ—¥:</span>
                        <span className={styles.metaValue}>{formatDate(mindMap.createdAt)}</span>
                      </div>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>æ›´æ–°æ—¥:</span>
                        <span className={styles.metaValue}>{formatDate(mindMap.updatedAt)}</span>
                      </div>
                    </div>
                  </div>
                  <div className={styles.cardActions}>
                    <Link 
                      href={`/mindmap?id=${mindMap.id}`} 
                      className={styles.editButton}
                    >
                      ç·¨é›†
                    </Link>
                    <button 
                      onClick={() => mindMap.id && handleDelete(mindMap.id)}
                      className={styles.deleteButton}
                    >
                      å‰Šé™¤
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </>
        )}
      </main>

      <TitleInputModal
        isOpen={showTitleModal}
        onClose={handleTitleModalClose}
        onConfirm={handleTitleConfirm}
        onAutoGenerate={handleAutoGenerate}
      />

      {/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ */}
      {isGenerating && (
        <div className={styles.loadingOverlay}>
          <div className={styles.loadingContent}>
            <div className={styles.spinner}></div>
            <h2>ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ã‚’è‡ªå‹•ç”Ÿæˆä¸­...</h2>
            <p>{generationProgress}</p>
            <div className={styles.progressBar}>
              <div className={styles.progressBarFill}></div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
