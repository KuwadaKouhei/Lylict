'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useDispatch } from 'react-redux';
import { getAllMindMaps, deleteMindMap, MindMap } from '@/lib/mindmapService';
import { AppDispatch } from '@/lib/store';
import { createAutoGeneratedMindMap } from '@/lib/features/mindmap/mindmapSlice';
import { onAuthStateChange } from '@/lib/auth';
import { User } from 'firebase/auth';
import TitleInputModal from '@/components/TitleInputModal';
import LoginButton from '@/components/LoginButton';
import { fetchGenerationalAssociations, fetchAssociations } from '@/lib/aiApiService';
import styles from './page.module.css';

export default function Home() {
  const [mindMaps, setMindMaps] = useState<MindMap[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showTitleModal, setShowTitleModal] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationProgress, setGenerationProgress] = useState('');
  const [user, setUser] = useState<User | null>(null);

  const router = useRouter();
  const dispatch: AppDispatch = useDispatch();

  useEffect(() => {
    // 認証状態の監視
    const unsubscribe = onAuthStateChange((user) => {
      setUser(user);
      // ユーザーがログインしたらマインドマップを読み込み
      if (user) {
        loadMindMaps();
      } else {
        setMindMaps([]);
        setLoading(false); // 未認証の場合はローディングを終了
      }
    });
    
    // コンポーネントのアンマウント時にローディング状態をリセット
    return () => {
      setIsGenerating(false);
      setGenerationProgress('');
      unsubscribe();
    };
  }, []);

  const loadMindMaps = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // 認証状態を詳細チェック
      console.log('loadMindMaps 実行時の認証状態:', {
        user: user,
        uid: user?.uid,
        isAuthenticated: !!user
      });
      
      const maps = await getAllMindMaps();
      setMindMaps(maps);
    } catch (err: any) {
      console.error('マインドマップの読み込みエラー:', err);
      if (err.message === 'AUTHENTICATION_REQUIRED') {
        // 認証が必要な場合は空の配列をセットしてエラーは表示しない
        setMindMaps([]);
        setError(null); // エラーメッセージもクリア
      } else {
        setError('マインドマップの読み込み中にエラーが発生しました');
      }
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm('このマインドマップを削除しますか？')) return;
    
    try {
      await deleteMindMap(id);
      setMindMaps(mindMaps.filter(map => map.id !== id));
    } catch (err) {
      console.error('マインドマップの削除エラー:', err);
      setError('マインドマップの削除中にエラーが発生しました');
    }
  };

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const handleCreateNew = () => {
    if (!user) {
      alert('マインドマップを作成するには、まずログインしてください。');
      return;
    }
    setShowTitleModal(true);
  };

  const handleTitleConfirm = (title: string, firstWord: string) => {
    setShowTitleModal(false);
    // タイトルと最初のワードをURLパラメータとして渡してマインドマップ画面に遷移
    router.push(`/mindmap?title=${encodeURIComponent(title)}&firstWord=${encodeURIComponent(firstWord)}`);
  };

  const handleAutoGenerate = async (title: string, keyword: string, mode: 'noun' | 'poetic', generations: number = 2) => {
    setShowTitleModal(false);
    setIsGenerating(true);
    setGenerationProgress('マインドマップの自動生成を開始しています...');
    
    try {
      // 世代数ベースの階層構造データを作成
      interface GenerationNode {
        word: string;
        id: string;
        generation: number;
        parentId?: string;
        children?: GenerationNode[];
      }

      // 世代別APIを使用した階層構造構築
      const buildGenerationTreeWithAPI = async (): Promise<GenerationNode[]> => {
        let nodeCounter = 1;
        const allNodes: GenerationNode[] = [];

        // 第1世代（キーワード）
        const rootNode: GenerationNode = {
          word: keyword,
          id: nodeCounter.toString(),
          generation: 1,
          children: []
        };
        allNodes.push(rootNode);
        nodeCounter++;

        try {
          // 世代別APIを呼び出し（aiApiService.tsからインポート）
          setGenerationProgress(`${generations}世代の連想語を生成中...`);
          const apiResponse = await fetchGenerationalAssociations(keyword, generations);
          
          if (apiResponse.status === 'error') {
            throw new Error(`API エラー: ${apiResponse.message}`);
          }

          if (apiResponse.generations && apiResponse.generations.length > 0) {
            // 各世代のデータを処理
            setGenerationProgress(`連想語データを処理中... (${apiResponse.generations.length}個の世代データ)`);
            
            // 世代ごとに処理
            apiResponse.generations.forEach((genData: import('@/lib/aiApiService').GenerationResult) => {
              if (genData.generation_number === 2) {
                // 第2世代（キーワードからの直接連想語）
                genData.results.forEach((wordObj: import('@/lib/aiApiService').AssociationWord) => {
                  const childNode: GenerationNode = {
                    word: wordObj.word,
                    id: nodeCounter.toString(),
                    generation: 2,
                    parentId: rootNode.id,
                    children: []
                  };
                  allNodes.push(childNode);
                  rootNode.children!.push(childNode);
                  nodeCounter++;
                });
              } else if (genData.generation_number === 3) {
                // 第3世代（第2世代の各語からの連想語）
                const parentNode = allNodes.find(node => 
                  node.generation === 2 && node.word === genData.parent_word
                );
                
                if (parentNode) {
                  genData.results.forEach((wordObj: import('@/lib/aiApiService').AssociationWord) => {
                    const childNode: GenerationNode = {
                      word: wordObj.word,
                      id: nodeCounter.toString(),
                      generation: 3,
                      parentId: parentNode.id,
                      children: []
                    };
                    allNodes.push(childNode);
                    parentNode.children!.push(childNode);
                    nodeCounter++;
                  });
                } else {
                  console.warn(`⚠️ 第3世代の親ノード「${genData.parent_word}」が見つかりません`);
                }
              }
            });
            
          }

          return allNodes;
          
        } catch (error) {
          // フォールバックとして従来の方法を使用
          return await buildGenerationTreeTraditional();
        }
      };

      // 従来の階層構造構築（フォールバック用）
      const buildGenerationTreeTraditional = async (): Promise<GenerationNode[]> => {
        let nodeCounter = 1;
        const allNodes: GenerationNode[] = [];

        // 第1世代（キーワード）
        const rootNode: GenerationNode = {
          word: keyword,
          id: nodeCounter.toString(),
          generation: 1,
          children: []
        };
        allNodes.push(rootNode);
        nodeCounter++;

        if (generations >= 2) {
          // 第2世代（キーワードから8つの連想語）
          setGenerationProgress('第2世代の連想語を生成中...');
          const secondGenWords = await fetchAssociations(keyword, 8);
          if (secondGenWords.length === 0) {
            throw new Error('第2世代の連想語が生成されませんでした。');
          }

          for (const word of secondGenWords) {
            const childNode: GenerationNode = {
              word: word,
              id: nodeCounter.toString(),
              generation: 2,
              parentId: rootNode.id,
              children: []
            };
            allNodes.push(childNode);
            rootNode.children!.push(childNode);
            nodeCounter++;
          }

          if (generations === 3) {
            // 第3世代（各連想語からさらに3つずつの連想語）
            setGenerationProgress('第3世代の連想語を生成中...');
            const previousGenNodes = allNodes.filter(node => node.generation === 2);
            
            for (const parentNode of previousGenNodes) {
              try {
                const childWords = await fetchAssociations(parentNode.word, 3);
                
                for (const word of childWords) {
                  const childNode: GenerationNode = {
                    word: word,
                    id: nodeCounter.toString(),
                    generation: 3,
                    parentId: parentNode.id,
                    children: []
                  };
                  allNodes.push(childNode);
                  parentNode.children!.push(childNode);
                  nodeCounter++;
                }
              } catch (error) {
                // 個別の失敗は無視して続行
              }
            }
          }
        }

        return allNodes;
      };

      const generationNodes = await buildGenerationTreeWithAPI();
      
      if (generationNodes.length === 0) {
        throw new Error('連想語が生成されませんでした。キーワードを変更してお試しください。');
      }
      
      setGenerationProgress('ノードレイアウトを最適化中...');
      
      // 高度な衝突検出とレイアウト最適化システム
      
      // エッジの交差を検出する関数（改良版）
      const doLinesIntersect = (
        line1: { start: { x: number, y: number }, end: { x: number, y: number } }, 
        line2: { start: { x: number, y: number }, end: { x: number, y: number } }
      ) => {
        const { start: p1, end: p2 } = line1;
        const { start: p3, end: p4 } = line2;
        
        const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        if (Math.abs(denominator) < 0.0001) return false;
        
        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
        
        return ua >= 0.01 && ua <= 0.99 && ub >= 0.01 && ub <= 0.99; // 端点近くの交差は無視
      };

      // エッジとノードの衝突検出
      const doesEdgeIntersectNode = (edgeLine: { start: { x: number, y: number }, end: { x: number, y: number } }, 
                                    node: { position: { x: number, y: number } }, nodeWidth = 100, nodeHeight = 50) => {
        const { start, end } = edgeLine;
        const nodeRect = {
          left: node.position.x - 10, // ノード境界にマージンを追加
          right: node.position.x + nodeWidth + 10,
          top: node.position.y - 10,
          bottom: node.position.y + nodeHeight + 10
        };
        
        // 線分と矩形の交差判定
        const lineLength = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
        const steps = Math.ceil(lineLength / 5); // 5px間隔でチェック
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.x + (end.x - start.x) * t;
          const y = start.y + (end.y - start.y) * t;
          
          if (x >= nodeRect.left && x <= nodeRect.right && y >= nodeRect.top && y <= nodeRect.bottom) {
            return true;
          }
        }
        return false;
      };

      // ノード位置から実際のエッジライン情報を計算（改良版）
      const getEdgeLine = (sourceNode: any, targetNode: any) => {
        const nodeWidth = 100, nodeHeight = 50;
        const sourceCenter = {
          x: sourceNode.position.x + nodeWidth / 2,
          y: sourceNode.position.y + nodeHeight / 2
        };
        const targetCenter = {
          x: targetNode.position.x + nodeWidth / 2,
          y: targetNode.position.y + nodeHeight / 2
        };
        
        return { start: sourceCenter, end: targetCenter };
      };

      // 等間隔配置に最適化されたスコア計算
      const calculateLayoutScore = (newNode: any, newEdge: any, existingNodes: any[], existingEdges: any[]) => {
        let score = 0;
        const testNodes = [...existingNodes, newNode];
        
        // エッジ交差ペナルティ (絶対優先)
        const intersections = countEdgeIntersections(newEdge, existingEdges, testNodes);
        score -= intersections * 2000; // より高いペナルティ
        
        // エッジ-ノード衝突ペナルティ (絶対優先)
        const sourceNode = testNodes.find(n => n.id === newEdge.source);
        if (sourceNode) {
          const edgeLine = getEdgeLine(sourceNode, newNode);
          for (const node of existingNodes) {
            if (node.id !== sourceNode?.id && node.id !== newNode.id) {
              if (doesEdgeIntersectNode(edgeLine, node)) {
                score -= 1500; // より高いペナルティ
              }
            }
          }
        }
        
        // エッジ長最適化 (短い方が良い)
        if (sourceNode) {
          const edgeLength = Math.sqrt(
            (newNode.position.x + 50 - sourceNode.position.x - 50) ** 2 + 
            (newNode.position.y + 25 - sourceNode.position.y - 25) ** 2
          );
          score -= edgeLength * 1.5; // エッジ長を重視
        }
        
        // 等間隔性ボーナス (同世代内での均等分散)
        const sameGenerationNodes = testNodes.filter(n => n.generation === newNode.generation);
        if (sameGenerationNodes.length > 1) {
          // 同世代ノード間の角度の均等性をチェック
          const angles = sameGenerationNodes.map(node => {
            return Math.atan2(node.position.y + 25, node.position.x + 50) * 180 / Math.PI;
          });
          
          angles.sort((a, b) => a - b);
          const angleGaps = [];
          for (let i = 0; i < angles.length; i++) {
            const nextAngle = angles[(i + 1) % angles.length];
            let gap = nextAngle - angles[i];
            if (gap < 0) gap += 360;
            angleGaps.push(gap);
          }
          
          const idealGap = 360 / angles.length;
          const gapVariance = angleGaps.reduce((sum, gap) => sum + Math.abs(gap - idealGap), 0);
          score -= gapVariance * 2; // 等間隔からの偏差をペナライズ
        }
        
        // 最小ノード間距離ボーナス
        let minDistance = Infinity;
        for (const node of existingNodes) {
          if (node.id !== newNode.id) {
            const distance = Math.sqrt(
              (newNode.position.x - node.position.x) ** 2 + 
              (newNode.position.y - node.position.y) ** 2
            );
            minDistance = Math.min(minDistance, distance);
          }
        }
        
        const idealMinDistance = 110; // ノード幅 + マージン
        if (minDistance < idealMinDistance) {
          score -= (idealMinDistance - minDistance) * 10; // 近すぎる場合の大きなペナルティ
        } else if (minDistance > idealMinDistance * 1.5) {
          score -= (minDistance - idealMinDistance * 1.5) * 0.5; // 遠すぎる場合の軽いペナルティ
        }
        
        return score;
      };

      // エッジ交差数をカウントする関数（改良版）
      const countEdgeIntersections = (newEdge: any, existingEdges: any[], allNodes: any[]) => {
        const sourceNode = allNodes.find(n => n.id === newEdge.source);
        const targetNode = allNodes.find(n => n.id === newEdge.target);
        
        if (!sourceNode || !targetNode) return 0;
        
        const newLine = getEdgeLine(sourceNode, targetNode);
        let intersections = 0;
        
        for (const edge of existingEdges) {
          if (edge.source === newEdge.source || edge.target === newEdge.target || 
              edge.source === newEdge.target || edge.target === newEdge.source) continue;
              
          const edgeSource = allNodes.find(n => n.id === edge.source);
          const edgeTarget = allNodes.find(n => n.id === edge.target);
          
          if (edgeSource && edgeTarget) {
            const existingLine = getEdgeLine(edgeSource, edgeTarget);
            if (doLinesIntersect(newLine, existingLine)) {
              intersections++;
            }
          }
        }
        
        return intersections;
      };

      // 世代ごとのノード配置を計算（完全新規実装）
      const calculateGenerationLayout = (nodes: GenerationNode[]) => {
        const reactFlowNodes: any[] = [];
        const reactFlowEdges: any[] = [];
        
        // ノードサイズの定数定義
        const nodeWidth = 150;  // CustomNodeの推定幅
        const nodeHeight = 50;  // CustomNodeの推定高さ
        const minNodeDistance = 200; // ノード間の最小距離
        
        // 世代別にノードを分類
        const nodesByGeneration = nodes.reduce((acc, node) => {
          if (!acc[node.generation]) acc[node.generation] = [];
          acc[node.generation].push(node);
          return acc;
        }, {} as Record<number, GenerationNode[]>);

        const maxGeneration = Math.max(...Object.keys(nodesByGeneration).map(Number));
        
        // 改良された円状配置アルゴリズム
        const calculateOptimalLayout = () => {
          
          // 各世代の最適半径を計算
          const calculateOptimalRadii = () => {
            const radii: Record<number, number> = {};
            
            for (let gen = 1; gen <= maxGeneration; gen++) {
              if (gen === 1) {
                radii[gen] = 0; // 中心
              } else {
                const nodeCount = nodesByGeneration[gen]?.length || 0;
                if (nodeCount === 0) continue;
                
                // 円周上に配置するために必要な最小半径を計算
                // 隣接ノード間の距離がminNodeDistance以上になるような半径
                const requiredCircumference = nodeCount * minNodeDistance;
                const minRadiusForSpacing = requiredCircumference / (2 * Math.PI);
                
                // 前世代からの最小距離（第3世代以降は適度に短く）
                const prevRadius = radii[gen - 1] || 0;
                const generationGap = gen >= 3 ? minNodeDistance * 0.8 : minNodeDistance; // 第3世代以降は20%短く
                const minRadiusFromPrev = prevRadius + generationGap;
                
                // より大きい方を採用
                radii[gen] = Math.max(minRadiusForSpacing, minRadiusFromPrev);
                
              }
            }
            
            return radii;
          };
          
          const optimalRadii = calculateOptimalRadii();
          
          // 各世代のノードを配置
          Object.entries(nodesByGeneration)
            .sort(([a], [b]) => parseInt(a) - parseInt(b))
            .forEach(([genStr, genNodes]) => {
              const generation = parseInt(genStr);
              const radius = optimalRadii[generation];
              
              
              if (generation === 1) {
                // 第1世代（中心ノード）
                const centerNode = {
                  id: genNodes[0].id,
                  type: 'customNode',
                  data: { 
                    label: genNodes[0].word, 
                    isNew: false,
                    generation: genNodes[0].generation 
                  },
                  position: { x: -(nodeWidth / 2), y: -(nodeHeight / 2) },
                };
                reactFlowNodes.push(centerNode);
                                
              } else if (generation === 2) {
                // 第2世代：中心周りに完全等間隔配置（90度回転）
                const nodeCount = genNodes.length;
                
                genNodes.forEach((node, index) => {
                  // 90度から開始して等間隔に配置
                  const angle = 90 + (index * 360) / nodeCount;
                  const angleRad = (angle * Math.PI) / 180;
                  
                  // 極座標から直交座標への変換
                  const position = {
                    x: Math.cos(angleRad) * radius - (nodeWidth / 2),
                    y: Math.sin(angleRad) * radius - (nodeHeight / 2),
                  };
                  
                  const reactFlowNode = {
                    id: node.id,
                    type: 'customNode',
                    data: { 
                      label: node.word, 
                      isNew: false,
                      generation: node.generation 
                    },
                    position: position,
                  };
                  reactFlowNodes.push(reactFlowNode);
                                    
                  // エッジを作成（中心ノードへの接続）
                  if (node.parentId) {
                    const edge = {
                      id: `e${node.parentId}-${node.id}`,
                      source: node.parentId,
                      target: node.id,
                      type: 'floating',
                    };
                    reactFlowEdges.push(edge);
                  }
                });
                
              } else {
                // 第3世代以降：親ノードの延長線上に放射状配置
                // 親ノードごとにグループ化
                const parentGroups = genNodes.reduce((groups, node) => {
                  const parentId = node.parentId!;
                  if (!groups[parentId]) groups[parentId] = [];
                  groups[parentId].push(node);
                  return groups;
                }, {} as Record<string, GenerationNode[]>);
                
                Object.entries(parentGroups).forEach(([parentId, children]) => {
                  const parentNode = reactFlowNodes.find(n => n.id === parentId);
                  if (!parentNode) return;
                  
                  // 親ノードの中心から見た角度を計算（中心ノードからの放射角度）
                  const parentAngle = Math.atan2(
                    parentNode.position.y + (nodeHeight / 2), 
                    parentNode.position.x + (nodeWidth / 2)
                  );
                  
                  children.forEach((node, childIndex) => {
                    let angle = parentAngle;
                    
                    // 同じ親に複数の子がある場合、30度範囲内で等間隔に配置
                    if (children.length > 1) {
                      const totalAngleRange = 30; // 度（30度範囲に調整）
                      const angleOffset = totalAngleRange / (children.length - 1);
                      const startOffset = -totalAngleRange / 2;
                      angle = parentAngle + (startOffset + childIndex * angleOffset) * Math.PI / 180;
                    }
                    
                    // 親ノードの延長線上に配置（中心からの放射線方向）
                    const position = {
                      x: Math.cos(angle) * radius - (nodeWidth / 2),
                      y: Math.sin(angle) * radius - (nodeHeight / 2),
                    };
                    
                    const reactFlowNode = {
                      id: node.id,
                      type: 'customNode',
                      data: { 
                        label: node.word, 
                        isNew: false,
                        generation: node.generation 
                      },
                      position: position,
                    };
                    reactFlowNodes.push(reactFlowNode);
                    
                    // エッジを作成（親ノードへの接続）
                    const edge = {
                      id: `e${parentId}-${node.id}`,
                      source: parentId,
                      target: node.id,
                      type: 'floating',
                    };
                    reactFlowEdges.push(edge);
                  });
                });
              }
            });
        };
        
        calculateOptimalLayout();
                
        return { nodes: reactFlowNodes, edges: reactFlowEdges };
      };

      const { nodes: generatedNodes, edges: generatedEdges } = calculateGenerationLayout(generationNodes);
      
      setGenerationProgress('マインドマップを作成中...');
            
      dispatch(createAutoGeneratedMindMap({
        title: title,
        nodes: generatedNodes,
        edges: generatedEdges
      }));
      
      // 自動生成フラグ付きでマインドマップ画面に遷移
      router.push('/mindmap?autoGenerate=true');
    } catch (error: any) {
      console.error('❌ 自動生成エラー詳細:', {
        error,
        errorType: error?.constructor?.name,
        errorMessage: error?.message,
        errorStack: error?.stack
      });
      setIsGenerating(false);
      setGenerationProgress('');
      
      let errorMessage = 'マインドマップの自動生成中にエラーが発生しました。';
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        errorMessage = 'APIサーバーに接続できません。\n\n以下を確認してください:\n1. 本番APIサーバーが稼働しているか\n2. サーバーが動作しているか\n3. ネットワーク接続が正常か\n\nローカル開発時は:\nD:/training/w2v_associateAPI で\n"pip install -r requirements.txt"\n"python main.py"';
      } else if (error instanceof Error) {
        if (error.message.includes('API内部エラー')) {
          errorMessage = `${error.message}\n\nAPIサーバーの設定を確認してください:\n1. Word2Vecモデルが正しく読み込まれているか\n2. 日本語の単語データが利用可能か\n3. サーバーログでエラー詳細を確認`;
        } else {
          errorMessage = `エラー: ${error.message}`;
        }
      }
      
      alert(errorMessage);
    }
  };

  const handleTitleModalClose = () => {
    setShowTitleModal(false);
  };

  if (loading) {
    return (
      <div className={styles.container}>
        <div className={styles.loading}>読み込み中...</div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <header className={styles.header}>
        <div className={styles.headerTop}>
          <div className={styles.titleSection}>
            <h1 className={styles.title}>Lylict</h1>
            <p className={styles.subtitle}>アイデアを可視化し、創造性を解き放とう</p>
          </div>
          <LoginButton user={user} onUserChange={setUser} />
        </div>
        <button 
          onClick={handleCreateNew} 
          className={styles.createButton}
          disabled={!user}
          style={{ opacity: !user ? 0.6 : 1, cursor: !user ? 'not-allowed' : 'pointer' }}
        >
          新しいマインドマップを作成
        </button>
      </header>

      <main className={styles.main}>
        {error && (
          <div className={styles.error}>
            <span>{error}</span>
            <button onClick={loadMindMaps} className={styles.retryButton}>
              再試行
            </button>
          </div>
        )}

        {!user ? (
          <div className={styles.empty}>
            <div className={styles.emptyIcon}>🔐</div>
            <h2>ログインが必要です</h2>
            <p>マインドマップを作成・管理するには、Googleアカウントでログインしてください</p>
          </div>
        ) : mindMaps.length === 0 ? (
          <div className={styles.empty}>
            <div className={styles.emptyIcon}>🧠</div>
            <h2>まだマインドマップがありません</h2>
            <p>最初のマインドマップを作成して、アイデアの整理を始めましょう</p>
            <button onClick={handleCreateNew} className={styles.createButton}>
              最初のマインドマップを作成
            </button>
          </div>
        ) : (
          <>
            <div className={styles.stats}>
              <span className={styles.count}>合計 {mindMaps.length} 個のマインドマップ</span>
            </div>
            <div className={styles.grid}>
              {mindMaps.map((mindMap) => (
                <div key={mindMap.id} className={styles.card}>
                  <div className={styles.cardContent}>
                    <h3 className={styles.cardTitle}>{mindMap.title}</h3>
                    <div className={styles.cardMeta}>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>ノード数:</span>
                        <span className={styles.metaValue}>{mindMap.nodes.length}</span>
                      </div>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>作成日:</span>
                        <span className={styles.metaValue}>{formatDate(mindMap.createdAt)}</span>
                      </div>
                      <div className={styles.metaItem}>
                        <span className={styles.metaLabel}>更新日:</span>
                        <span className={styles.metaValue}>{formatDate(mindMap.updatedAt)}</span>
                      </div>
                    </div>
                  </div>
                  <div className={styles.cardActions}>
                    <Link 
                      href={`/mindmap?id=${mindMap.id}`} 
                      className={styles.editButton}
                    >
                      編集
                    </Link>
                    <button 
                      onClick={() => mindMap.id && handleDelete(mindMap.id)}
                      className={styles.deleteButton}
                    >
                      削除
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </>
        )}
      </main>

      <TitleInputModal
        isOpen={showTitleModal}
        onClose={handleTitleModalClose}
        onConfirm={handleTitleConfirm}
        onAutoGenerate={handleAutoGenerate}
      />

      {/* ローディング画面 */}
      {isGenerating && (
        <div className={styles.loadingOverlay}>
          <div className={styles.loadingContent}>
            <div className={styles.spinner}></div>
            <h2>マインドマップを自動生成中...</h2>
            <p>{generationProgress}</p>
            <div className={styles.progressBar}>
              <div className={styles.progressBarFill}></div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
